Index: external/mit/lua/dist/src/lauxlib.c
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/lauxlib.c,v
retrieving revision 1.6
diff -u -r1.6 lauxlib.c
--- external/mit/lua/dist/src/lauxlib.c	28 Jan 2016 14:41:39 -0000	1.6
+++ external/mit/lua/dist/src/lauxlib.c	10 Apr 2016 07:54:00 -0000
@@ -20,6 +20,12 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#else
+#include <iolib.h>
+#define BUFSIZ 1024
+#define EOF -1
+#define errno -1
+#define strerror(n) "kernel lua: error"
 #endif /* _KERNEL */
 
 
@@ -228,7 +234,6 @@
 }
 
 
-#ifndef _KERNEL
 LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
   int en = errno;  /* calls to Lua API may change this value */
   if (stat) {
@@ -245,7 +250,6 @@
     return 3;
   }
 }
-#endif /* _KERNEL */
 
 
 #if !defined(l_inspectstat)	/* { */
@@ -630,16 +634,23 @@
 ** =======================================================
 */
 
-#ifndef _KERNEL
 typedef struct LoadF {
   int n;  /* number of pre-read characters */
+#ifndef _KERNEL
   FILE *f;  /* file being read */
+#else
+  int fd;
+  file_t *f;
+#endif
   char buff[BUFSIZ];  /* area for reading file */
 } LoadF;
 
 
 static const char *getF (lua_State *L, void *ud, size_t *size) {
   LoadF *lf = (LoadF *)ud;
+#ifdef _KERNEL
+  size_t sz = 0;
+#endif
   (void)L;  /* not used */
   if (lf->n > 0) {  /* are there pre-read characters to be read? */
     *size = lf->n;  /* return them (chars already in buffer) */
@@ -649,33 +660,51 @@
     /* 'fread' can return > 0 *and* set the EOF flag. If next call to
        'getF' called 'fread', it might still wait for user input.
        The next check avoids this problem. */
+#ifndef _KERNEL
     if (feof(lf->f)) return NULL;
     *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
+#else
+    kread(lf->fd, lf->buff, sizeof(lf->buff), &sz);
+    if (sz == 0)
+      return NULL;
+    *size = sz;
+#endif
   }
   return lf->buff;
 }
 
 
 static int errfile (lua_State *L, const char *what, int fnameindex) {
+#ifndef _KERNEL
   const char *serr = strerror(errno);
+#else
+  const char *serr = "kernel lua: file error";
+#endif
   const char *filename = lua_tostring(L, fnameindex) + 1;
   lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
   lua_remove(L, fnameindex);
   return LUA_ERRFILE;
 }
 
-
 static int skipBOM (LoadF *lf) {
   const char *p = "\xEF\xBB\xBF";  /* UTF-8 BOM mark */
   int c;
   lf->n = 0;
   do {
+#ifndef _KERNEL
     c = getc(lf->f);
+#else
+    c = kgetc(lf->fd);
+#endif
     if (c == EOF || c != *(const unsigned char *)p++) return c;
     lf->buff[lf->n++] = c;  /* to be read by the parser */
   } while (*p != '\0');
   lf->n = 0;  /* prefix matched; discard it */
+#ifndef _KERNEL
   return getc(lf->f);  /* return next character */
+#else
+  return kgetc(lf->fd);
+#endif
 }
 
 
@@ -690,9 +719,17 @@
   int c = *cp = skipBOM(lf);
   if (c == '#') {  /* first line is a comment (Unix exec. file)? */
     do {  /* skip first line */
+#ifndef _KERNEL
       c = getc(lf->f);
+#else
+      c = kgetc(lf->fd);
+#endif
     } while (c != EOF && c != '\n') ;
+#ifndef _KERNEL
     *cp = getc(lf->f);  /* skip end-of-line, if present */
+#else
+    *cp = kgetc(lf->fd);
+#endif
     return 1;  /* there was a comment */
   }
   else return 0;  /* no comment */
@@ -706,34 +743,47 @@
   int c;
   int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
   if (filename == NULL) {
+#ifndef _KERNEL
     lua_pushliteral(L, "=stdin");
     lf.f = stdin;
+#endif
   }
   else {
     lua_pushfstring(L, "@%s", filename);
+#ifndef _KERNEL
     lf.f = fopen(filename, "r");
+#else
+    lf.f = kfopen(filename, "r", &lf.fd);
+#endif
     if (lf.f == NULL) return errfile(L, "open", fnameindex);
   }
   if (skipcomment(&lf, &c))  /* read initial portion */
     lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
+#ifndef _KERNEL
   if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
     lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
     if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
     skipcomment(&lf, &c);  /* re-read initial portion */
   }
+#endif
   if (c != EOF)
     lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
   status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
+#ifndef _KERNEL
   readstatus = ferror(lf.f);
   if (filename) fclose(lf.f);  /* close file (even in case of errors) */
+#elseif
+  if (filename) kfclose(lf.fd);
+#endif
+#ifndef _KERNEL
   if (readstatus) {
     lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
     return errfile(L, "read", fnameindex);
   }
+#endif
   lua_remove(L, fnameindex);
   return status;
 }
-#endif /* _KERNEL */
 
 
 typedef struct LoadS {
Index: external/mit/lua/dist/src/lauxlib.h
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/lauxlib.h,v
retrieving revision 1.4
diff -u -r1.4 lauxlib.h
--- external/mit/lua/dist/src/lauxlib.h	28 Jan 2016 14:41:39 -0000	1.4
+++ external/mit/lua/dist/src/lauxlib.h	10 Apr 2016 07:54:00 -0000
@@ -71,8 +71,8 @@
 LUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,
                                    const char *const lst[]);
 
-#ifndef _KERNEL
 LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
+#ifndef _KERNEL
 LUALIB_API int (luaL_execresult) (lua_State *L, int stat);
 #endif /* _KERNEL */
 
@@ -83,12 +83,10 @@
 LUALIB_API int (luaL_ref) (lua_State *L, int t);
 LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);
 
-#ifndef _KERNEL
 LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
                                                const char *mode);
 
 #define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)
-#endif /* _KERNEL */
 
 LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
                                    const char *name, const char *mode);
@@ -182,7 +180,6 @@
 
 
 
-#ifndef _KERNEL
 /*
 ** {======================================================
 ** File handles for IO library
@@ -198,13 +195,20 @@
 #define LUA_FILEHANDLE          "FILE*"
 
 
+#ifndef _KERNEL
 typedef struct luaL_Stream {
   FILE *f;  /* stream (NULL for incompletely created streams) */
   lua_CFunction closef;  /* to close stream (NULL for closed streams) */
 } luaL_Stream;
+#else
+typedef struct luaL_Stream {
+  file_t *f;  /* stream (NULL for incompletely created streams) */
+  int fd;
+  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
+} luaL_Stream;
+#endif
 
 /* }====================================================== */
-#endif /* _KERNEL */
 
 
 
Index: external/mit/lua/dist/src/lbaselib.c
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/lbaselib.c,v
retrieving revision 1.6
diff -u -r1.6 lbaselib.c
--- external/mit/lua/dist/src/lbaselib.c	28 Jan 2016 14:41:39 -0000	1.6
+++ external/mit/lua/dist/src/lbaselib.c	10 Apr 2016 07:54:00 -0000
@@ -289,7 +289,6 @@
 }
 
 
-#ifndef _KERNEL
 static int luaB_loadfile (lua_State *L) {
   const char *fname = luaL_optstring(L, 1, NULL);
   const char *mode = luaL_optstring(L, 2, NULL);
@@ -297,7 +296,6 @@
   int status = luaL_loadfilex(L, fname, mode);
   return load_aux(L, status, env);
 }
-#endif /* _KERNEL */
 
 
 /*
@@ -360,7 +358,6 @@
 /* }====================================================== */
 
 
-#ifndef _KERNEL
 static int dofilecont (lua_State *L, int d1, lua_KContext d2) {
   (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */
   return lua_gettop(L) - 1;
@@ -375,7 +372,6 @@
   lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
   return dofilecont(L, 0, 0);
 }
-#endif /* _KERNEL */
 
 
 static int luaB_assert (lua_State *L) {
@@ -462,15 +458,11 @@
 static const luaL_Reg base_funcs[] = {
   {"assert", luaB_assert},
   {"collectgarbage", luaB_collectgarbage},
-#ifndef _KERNEL
   {"dofile", luaB_dofile},
-#endif /* _KERNEL */
   {"error", luaB_error},
   {"getmetatable", luaB_getmetatable},
   {"ipairs", luaB_ipairs},
-#ifndef _KERNEL
   {"loadfile", luaB_loadfile},
-#endif /* _KERNEL */
   {"load", luaB_load},
 #if defined(LUA_COMPAT_LOADSTRING)
   {"loadstring", luaB_load},
Index: external/mit/lua/dist/src/linit.c
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/linit.c,v
retrieving revision 1.5
diff -u -r1.5 linit.c
--- external/mit/lua/dist/src/linit.c	28 Jan 2016 14:41:39 -0000	1.5
+++ external/mit/lua/dist/src/linit.c	10 Apr 2016 07:54:00 -0000
@@ -50,14 +50,10 @@
 #endif /* _KERNEL */
   {LUA_COLIBNAME, luaopen_coroutine},
   {LUA_TABLIBNAME, luaopen_table},
-#ifndef _KERNEL
   {LUA_IOLIBNAME, luaopen_io},
   {LUA_OSLIBNAME, luaopen_os},
-#endif /* _KERNEL */
   {LUA_STRLIBNAME, luaopen_string},
-#ifndef _KERNEL
   {LUA_MATHLIBNAME, luaopen_math},
-#endif /* _KERNEL */
   {LUA_UTF8LIBNAME, luaopen_utf8},
   {LUA_DBLIBNAME, luaopen_debug},
 #if defined(LUA_COMPAT_BITLIB)
Index: external/mit/lua/dist/src/liolib.c
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/liolib.c,v
retrieving revision 1.5
diff -u -r1.5 liolib.c
--- external/mit/lua/dist/src/liolib.c	28 Jan 2016 14:41:39 -0000	1.5
+++ external/mit/lua/dist/src/liolib.c	10 Apr 2016 07:54:00 -0000
@@ -11,13 +11,20 @@
 
 #include "lprefix.h"
 
-
+#ifndef _KERNEL
 #include <ctype.h>
 #include <errno.h>
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#else
+#include <iolib.h>
+#define FILE LStream
+#define EOF -1
+#define errno -1
+#define strerror(n) "kernel lua: error"
+#endif
 
 #include "lua.h"
 
@@ -46,6 +53,7 @@
 
 #endif
 
+#ifndef _KERNEL
 /*
 ** {======================================================
 ** l_popen spawns a new process connected to the current
@@ -132,6 +140,7 @@
 #endif				/* } */
 
 /* }====================================================== */
+#endif
 
 
 #define IO_PREFIX	"_IO_"
@@ -148,6 +157,7 @@
 #define isclosed(p)	((p)->closef == NULL)
 
 
+#ifndef _KERNEL
 static int io_type (lua_State *L) {
   LStream *p;
   luaL_checkany(L, 1);
@@ -160,6 +170,7 @@
     lua_pushliteral(L, "file");
   return 1;
 }
+#endif
 
 
 static int f_tostring (lua_State *L) {
@@ -177,7 +188,11 @@
   if (isclosed(p))
     luaL_error(L, "attempt to use a closed file");
   lua_assert(p->f);
+#ifndef _KERNEL
   return p->f;
+#else
+  return p;
+#endif
 }
 
 
@@ -228,7 +243,11 @@
 */
 static int io_fclose (lua_State *L) {
   LStream *p = tolstream(L);
+#ifndef _KERNEL
   int res = fclose(p->f);
+#else
+  int res = kclose(p->fd);
+#endif
   return luaL_fileresult(L, (res == 0), NULL);
 }
 
@@ -240,12 +259,24 @@
   return p;
 }
 
-
+#ifndef _KERNEL
 static void opencheck (lua_State *L, const char *fname, const char *mode) {
+#else
+static LStream* opencheck (lua_State *L, const char *fname, const char *mode) {
+#endif
   LStream *p = newfile(L);
+#ifndef _KERNEL
   p->f = fopen(fname, mode);
+#else
+  int fd;
+  p->f = kfopen(fname, mode, &fd);
+  p->fd = fd;
+#endif
   if (p->f == NULL)
     luaL_error(L, "cannot open file '%s' (%s)", fname, strerror(errno));
+#ifdef _KERNEL
+  return p;
+#endif
 }
 
 
@@ -255,11 +286,18 @@
   LStream *p = newfile(L);
   const char *md = mode;  /* to traverse/check mode */
   luaL_argcheck(L, l_checkmode(md), 2, "invalid mode");
+#ifndef _KERNEL
   p->f = fopen(filename, mode);
+#else
+  int fd;
+  p->f = kfopen(filename, mode, &fd);
+  p->fd = fd;
+#endif
   return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
 }
 
 
+#ifndef _KERNEL
 /*
 ** function to close 'popen' files
 */
@@ -284,6 +322,7 @@
   p->f = tmpfile();
   return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;
 }
+#endif
 
 
 static FILE *getiofile (lua_State *L, const char *findex) {
@@ -292,7 +331,11 @@
   p = (LStream *)lua_touserdata(L, -1);
   if (isclosed(p))
     luaL_error(L, "standard %s file is closed", findex + IOPREF_LEN);
+#ifndef _KERNEL
   return p->f;
+#else
+  return p;
+#endif
 }
 
 
@@ -322,7 +365,7 @@
   return g_iofile(L, IO_OUTPUT, "w");
 }
 
-
+#ifndef _KERNEL
 static int io_readline (lua_State *L);
 
 
@@ -368,7 +411,6 @@
   return 1;
 }
 
-
 /*
 ** {======================================================
 ** READ
@@ -470,6 +512,7 @@
   lua_pushliteral(L, "");
   return (c != EOF);
 }
+#endif
 
 
 static int read_line (lua_State *L, FILE *f, int chop) {
@@ -479,10 +522,16 @@
   while (c != EOF && c != '\n') {  /* repeat until end of line */
     char *buff = luaL_prepbuffer(&b);  /* preallocate buffer */
     int i = 0;
+#ifndef _KERNEL
     l_lockfile(f);  /* no memory errors can happen inside the lock */
     while (i < LUAL_BUFFERSIZE && (c = l_getc(f)) != EOF && c != '\n')
+#else
+    while (i < LUAL_BUFFERSIZE && (c = kgetc(f->fd)) != EOF && c != '\n')
+#endif
       buff[i++] = c;
+#ifndef _KERNEL
     l_unlockfile(f);
+#endif
     luaL_addsize(&b, i);
   }
   if (!chop && c == '\n')  /* want a newline and have one? */
@@ -499,7 +548,11 @@
   luaL_buffinit(L, &b);
   do {  /* read file in chunks of LUAL_BUFFERSIZE bytes */
     char *p = luaL_prepbuffer(&b);
+#ifndef _KERNEL
     nr = fread(p, sizeof(char), LUAL_BUFFERSIZE, f);
+#else
+    kread(f->fd, (void*) p, LUAL_BUFFERSIZE, &nr);
+#endif
     luaL_addsize(&b, nr);
   } while (nr == LUAL_BUFFERSIZE);
   luaL_pushresult(&b);  /* close buffer */
@@ -512,7 +565,11 @@
   luaL_Buffer b;
   luaL_buffinit(L, &b);
   p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
+#ifndef _KERNEL
   nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */
+#else
+  kread(f->fd, (void*) p, n, &nr);
+#endif
   luaL_addsize(&b, nr);
   luaL_pushresult(&b);  /* close buffer */
   return (nr > 0);  /* true iff read something */
@@ -523,7 +580,9 @@
   int nargs = lua_gettop(L) - 1;
   int success;
   int n;
+#ifndef _KERNEL
   clearerr(f);
+#endif
   if (nargs == 0) {  /* no arguments? */
     success = read_line(L, f, 1);
     n = first+1;  /* to return 1 result */
@@ -534,15 +593,21 @@
     for (n = first; nargs-- && success; n++) {
       if (lua_type(L, n) == LUA_TNUMBER) {
         size_t l = (size_t)luaL_checkinteger(L, n);
+#ifndef _KERNEL
         success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+#else
+        success = (l == 0) ? 1 : read_chars(L, f, l);
+#endif
       }
       else {
         const char *p = luaL_checkstring(L, n);
         if (*p == '*') p++;  /* skip optional '*' (for compatibility) */
         switch (*p) {
+#ifndef _KERNEL
           case 'n':  /* number */
             success = read_number(L, f);
             break;
+#endif
           case 'l':  /* line */
             success = read_line(L, f, 1);
             break;
@@ -559,8 +624,10 @@
       }
     }
   }
+#ifndef _KERNEL
   if (ferror(f))
     return luaL_fileresult(L, 0, NULL);
+#endif
   if (!success) {
     lua_pop(L, 1);  /* remove last result */
     lua_pushnil(L);  /* push nil instead */
@@ -578,7 +645,7 @@
   return g_read(L, tofile(L), 2);
 }
 
-
+#ifndef _KERNEL
 static int io_readline (lua_State *L) {
   LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));
   int i;
@@ -606,6 +673,7 @@
     return 0;
   }
 }
+#endif
 
 /* }====================================================== */
 
@@ -614,6 +682,7 @@
   int nargs = lua_gettop(L) - arg;
   int status = 1;
   for (; nargs--; arg++) {
+#ifndef _KERNEL
     if (lua_type(L, arg) == LUA_TNUMBER) {
       /* optimization: could be done exactly as for strings */
       int len = lua_isinteger(L, arg)
@@ -622,10 +691,20 @@
       status = status && (len > 0);
     }
     else {
+#endif
       size_t l;
+#ifdef _KERNEL
+      size_t w;
+#endif
       const char *s = luaL_checklstring(L, arg, &l);
+#ifndef _KERNEL
       status = status && (fwrite(s, sizeof(char), l, f) == l);
+#else
+      status = status && (kwrite(f->fd, (void*)s, l, &w) == 0) && (w == l);
+#endif
+#ifndef _KERNEL
     }
+#endif
   }
   if (status) return 1;  /* file handle already on stack top */
   else return luaL_fileresult(L, status, NULL);
@@ -644,6 +723,7 @@
 }
 
 
+#ifndef _KERNEL
 static int f_seek (lua_State *L) {
   static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
   static const char *const modenames[] = {"set", "cur", "end", NULL};
@@ -683,6 +763,7 @@
 static int f_flush (lua_State *L) {
   return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);
 }
+#endif
 
 
 /*
@@ -690,15 +771,23 @@
 */
 static const luaL_Reg iolib[] = {
   {"close", io_close},
+#ifndef _KERNEL
   {"flush", io_flush},
+#endif
   {"input", io_input},
+#ifndef _KERNEL
   {"lines", io_lines},
+#endif
   {"open", io_open},
   {"output", io_output},
+#ifndef _KERNEL
   {"popen", io_popen},
+#endif
   {"read", io_read},
+#ifndef _KERNEL
   {"tmpfile", io_tmpfile},
   {"type", io_type},
+#endif
   {"write", io_write},
   {NULL, NULL}
 };
@@ -709,11 +798,15 @@
 */
 static const luaL_Reg flib[] = {
   {"close", io_close},
+#ifndef _KERNEL
   {"flush", f_flush},
   {"lines", f_lines},
+#endif
   {"read", f_read},
+#ifndef _KERNEL
   {"seek", f_seek},
   {"setvbuf", f_setvbuf},
+#endif
   {"write", f_write},
   {"__gc", f_gc},
   {"__tostring", f_tostring},
@@ -741,11 +834,12 @@
   return 2;
 }
 
-
+#ifndef _KERNEL
 static void createstdfile (lua_State *L, FILE *f, const char *k,
                            const char *fname) {
   LStream *p = newprefile(L);
   p->f = f;
+  p->f = f->f;
   p->closef = &io_noclose;
   if (k != NULL) {
     lua_pushvalue(L, -1);
@@ -753,15 +847,18 @@
   }
   lua_setfield(L, -2, fname);  /* add file to module */
 }
+#endif
 
 
 LUAMOD_API int luaopen_io (lua_State *L) {
   luaL_newlib(L, iolib);  /* new module */
   createmeta(L);
+#ifndef _KERNEL
   /* create (and set) default files */
   createstdfile(L, stdin, IO_INPUT, "stdin");
   createstdfile(L, stdout, IO_OUTPUT, "stdout");
   createstdfile(L, stderr, NULL, "stderr");
+#endif
   return 1;
 }
 
Index: external/mit/lua/dist/src/lmathlib.c
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/lmathlib.c,v
retrieving revision 1.5
diff -u -r1.5 lmathlib.c
--- external/mit/lua/dist/src/lmathlib.c	28 Jan 2016 14:41:39 -0000	1.5
+++ external/mit/lua/dist/src/lmathlib.c	10 Apr 2016 07:54:00 -0000
@@ -11,16 +11,17 @@
 
 #include "lprefix.h"
 
-
+#ifndef _KERNEL
 #include <stdlib.h>
 #include <math.h>
+#endif
 
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
-
+#ifndef _KERNEL
 #undef PI
 #define PI	(l_mathop(3.141592653589793238462643383279502884))
 
@@ -37,7 +38,17 @@
 #endif
 #endif				/* } */
 
+#else // _KERNEL
+#define HUGE_VAL (lua_Number)__builtin_huge_val()
+#define l_rand()   random()
+#ifndef srandom
+#define srandom(x) ;
+#endif
+#define l_srand(x) srandom(x)
+#endif
+
 
+#ifndef _KERNEL
 static int math_abs (lua_State *L) {
   if (lua_isinteger(L, 1)) {
     lua_Integer n = lua_tointeger(L, 1);
@@ -124,7 +135,7 @@
   }
   return 1;
 }
-
+#endif
 
 static int math_fmod (lua_State *L) {
   if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {
@@ -136,13 +147,16 @@
     else
       lua_pushinteger(L, lua_tointeger(L, 1) % d);
   }
+#ifndef _KERNEL
   else
     lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),
                                      luaL_checknumber(L, 2)));
+#endif
   return 1;
 }
 
 
+#ifndef _KERNEL
 /*
 ** next function does not use 'modf', avoiding problems with 'double*'
 ** (which is not compatible with 'float*') when lua_Number is not
@@ -209,6 +223,7 @@
   lua_pushnumber(L, luaL_checknumber(L, 1) * (PI / l_mathop(180.0)));
   return 1;
 }
+#endif
 
 
 static int math_min (lua_State *L) {
@@ -245,7 +260,11 @@
 */
 static int math_random (lua_State *L) {
   lua_Integer low, up;
+#ifndef _KERNEL
   double r = (double)l_rand() * (1.0 / ((double)L_RANDMAX + 1.0));
+#else
+  long r = l_rand();
+#endif
   switch (lua_gettop(L)) {  /* check number of arguments */
     case 0: {  /* no arguments */
       lua_pushnumber(L, (lua_Number)r);  /* Number between 0 and 1 */
@@ -267,7 +286,11 @@
   luaL_argcheck(L, low <= up, 1, "interval is empty"); 
   luaL_argcheck(L, low >= 0 || up <= LUA_MAXINTEGER + low, 1,
                    "interval too large");
+#ifndef _KERNEL
   r *= (double)(up - low) + 1.0;
+#else
+  r = r % (up - low);
+#endif
   lua_pushinteger(L, (lua_Integer)r + low);
   return 1;
 }
@@ -295,6 +318,7 @@
 }
 
 
+#ifndef _KERNEL
 /*
 ** {==================================================================
 ** Deprecated functions (for compatibility only)
@@ -345,10 +369,11 @@
 
 #endif
 /* }================================================================== */
-
+#endif
 
 
 static const luaL_Reg mathlib[] = {
+#ifndef _KERNEL
   {"abs",   math_abs},
   {"acos",  math_acos},
   {"asin",  math_asin},
@@ -359,19 +384,27 @@
   {"exp",   math_exp},
   {"tointeger", math_toint},
   {"floor", math_floor},
+#endif
   {"fmod",   math_fmod},
+#ifndef _KERNEL
   {"ult",   math_ult},
   {"log",   math_log},
+#endif
   {"max",   math_max},
   {"min",   math_min},
+#ifndef _KERNEL
   {"modf",   math_modf},
   {"rad",   math_rad},
+#endif
   {"random",     math_random},
   {"randomseed", math_randomseed},
+#ifndef _KERNEL
   {"sin",   math_sin},
   {"sqrt",  math_sqrt},
   {"tan",   math_tan},
+#endif
   {"type", math_type},
+#ifndef _KERNEL
 #if defined(LUA_COMPAT_MATHLIB)
   {"atan2", math_atan},
   {"cosh",   math_cosh},
@@ -385,6 +418,7 @@
   /* placeholders */
   {"pi", NULL},
   {"huge", NULL},
+#endif
   {"maxinteger", NULL},
   {"mininteger", NULL},
   {NULL, NULL}
@@ -396,8 +430,10 @@
 */
 LUAMOD_API int luaopen_math (lua_State *L) {
   luaL_newlib(L, mathlib);
+#ifndef _KERNEL
   lua_pushnumber(L, PI);
   lua_setfield(L, -2, "pi");
+#endif
   lua_pushnumber(L, (lua_Number)HUGE_VAL);
   lua_setfield(L, -2, "huge");
   lua_pushinteger(L, LUA_MAXINTEGER);
Index: external/mit/lua/dist/src/loslib.c
===================================================================
RCS file: /cvsroot/src/external/mit/lua/dist/src/loslib.c,v
retrieving revision 1.5
diff -u -r1.5 loslib.c
--- external/mit/lua/dist/src/loslib.c	28 Jan 2016 14:41:39 -0000	1.5
+++ external/mit/lua/dist/src/loslib.c	10 Apr 2016 07:54:00 -0000
@@ -11,18 +11,37 @@
 
 #include "lprefix.h"
 
-
+#ifndef _KERNEL
 #include <errno.h>
 #include <locale.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#else
+#include <sys/time.h>
+#include <sys/proc.h>
+#include <iolib.h>
+#include <mkstemp.h>
+#endif
 
 #include "lua.h"
 
 #include "lauxlib.h"
 #include "lualib.h"
 
+#ifdef _KERNEL
+
+#define LUA_TMPNAMTEMPLATE "/tmp/lua_XXXXXX"
+#define LUA_TMPNAMBUFSIZE 32
+
+#define lua_tmpnam(b,e) { \
+   		strcpy(b, LUA_TMPNAMTEMPLATE); \
+		e = mkstemp(b); \
+		if (e != -1) kclose(e); \
+		e = (e == -1); }
+
+#define remove(fname) kremove(fname)
+#endif
 
 /*
 ** {==================================================================
@@ -89,7 +108,7 @@
 
 /* }================================================================== */
 
-
+#ifndef _KERNEL
 /*
 ** {==================================================================
 ** Configuration for 'tmpnam':
@@ -139,20 +158,20 @@
     return 1;
   }
 }
-
+#endif
 
 static int os_remove (lua_State *L) {
   const char *filename = luaL_checkstring(L, 1);
   return luaL_fileresult(L, remove(filename) == 0, filename);
 }
 
-
+#ifndef _KERNEL
 static int os_rename (lua_State *L) {
   const char *fromname = luaL_checkstring(L, 1);
   const char *toname = luaL_checkstring(L, 2);
   return luaL_fileresult(L, rename(fromname, toname) == 0, NULL);
 }
-
+#endif
 
 static int os_tmpname (lua_State *L) {
   char buff[LUA_TMPNAMBUFSIZE];
@@ -164,19 +183,29 @@
   return 1;
 }
 
-
+#ifndef _KERNEL
 static int os_getenv (lua_State *L) {
   lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
   return 1;
 }
-
+#endif
 
 static int os_clock (lua_State *L) {
+#ifndef _KERNEL
   lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+#else
+  struct rusage ru;
+  long s;
+
+  getrusage1(curlwp->l_proc, RUSAGE_SELF, &ru);
+  s = ru.ru_utime.tv_sec * 1000000 + ru.ru_stime.tv_sec * 1000000
+      + ru.ru_utime.tv_usec + ru.ru_stime.tv_usec;
+  lua_pushinteger(L, s);
+#endif
   return 1;
 }
 
-
+#ifndef _KERNEL
 /*
 ** {======================================================
 ** Time/Date operations
@@ -303,12 +332,24 @@
   }
   return 1;
 }
+#endif
 
 
 static int os_time (lua_State *L) {
   time_t t;
+#ifdef _KERNEL
+  struct bintime bt;
+#endif
   if (lua_isnoneornil(L, 1))  /* called without args? */
+#ifndef _KERNEL
     t = time(NULL);  /* get current time */
+#else
+{
+    bintime(&bt);
+    t = bt.sec;
+}
+#endif
+#ifndef _KERNEL
   else {
     struct tm ts;
     luaL_checktype(L, 1, LUA_TTABLE);
@@ -322,13 +363,14 @@
     ts.tm_isdst = getboolfield(L, "isdst");
     t = mktime(&ts);
   }
+#endif
   if (t != (time_t)(l_timet)t || t == (time_t)(-1))
     luaL_error(L, "time result cannot be represented in this installation");
   l_pushtime(L, t);
   return 1;
 }
 
-
+#ifndef _KERNEL
 static int os_difftime (lua_State *L) {
   time_t t1 = l_checktime(L, 1);
   time_t t2 = l_checktime(L, 2);
@@ -362,18 +404,22 @@
   if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
   return 0;
 }
-
+#endif
 
 static const luaL_Reg syslib[] = {
   {"clock",     os_clock},
+#ifndef _KERNEL
   {"date",      os_date},
   {"difftime",  os_difftime},
   {"execute",   os_execute},
   {"exit",      os_exit},
   {"getenv",    os_getenv},
+#endif
   {"remove",    os_remove},
+#ifndef _KERNEL
   {"rename",    os_rename},
   {"setlocale", os_setlocale},
+#endif
   {"time",      os_time},
   {"tmpname",   os_tmpname},
   {NULL, NULL}
